# 父子shell

## 父子shell执行

1. source和点，执行脚本，只在当前shell环境中执行生效
2. 指定bash sh 解释器运行脚本，是开启subshell，开启子shell运行脚本命令
3. ./script，都会指定shebang，通过解释器运行，也是开启subshell运行命令

## 查看父子shell命令

1. pstree看到如下结果，就是父shell环境

```text
pstree

|-sshd-sshd-bash-pstree
```

2. 利用ps进程管理命令查看

```text
ps -ef 
-f 显示UID，PID，PPID
-e 列出所有进程的信息，如同-A选项option

ps -ef --forest

例如：
root        965      1  0 22:15 ?        00:00:00 /usr/sbin/sshd -D
root       1785    965  0 22:18 ?        00:00:00  \_ sshd: root@pts/0
root       1789   1785  0 22:18 pts/0    00:00:00  |   \_ -bash
root       1986   1789  0 23:38 pts/0    00:00:00  |       \_ ps -ef --forest

通过它的PID，PPID也可以看出来它们的层级关系
```

## 多个子shell

在当前shell中又运行了sh，就会开启一个子shell，利用exit退出子shell，只要输入exit，就能够退出子shell环境了。

多个子shell图示：

```text
root        965      1  0 22:15 ?        00:00:00 /usr/sbin/sshd -D
root       1785    965  0 22:18 ?        00:00:00  \_ sshd: root@pts/0
root       1789   1785  0 22:18 pts/0    00:00:00  |   \_ -bash
root       1988   1789  0 23:45 pts/0    00:00:00  |       \_ bash
root       1999   1988  0 23:45 pts/0    00:00:00  |           \_ bash
root       2010   1999  0 23:45 pts/0    00:00:00  |               \_ sh
root       2011   2010  0 23:45 pts/0    00:00:00  |                   \_ sh
root       2012   2011  0 23:45 pts/0    00:00:00  |                       \_ sh
root       2013   2012  0 23:45 pts/0    00:00:00  |                           \_ ps -ef --forest
```

## 创建进程列表

执行一些列命令必须用“;”隔开，如

```shell
ls;cd;pwd;echo "hello"
```

shell的进程列表的理念，需要使用()小括号，如下执行方式，就称之为，进程列表

```shell
(cd ~;pwd;ls ;cd /tmp/;pwd ;ls)
```

检测是否在子shell环境中：

```text
linux默认的有关shell的变量

#该变量的值特点，如果是0，就是当前shell环境中执行的，否则就是开辟子shell去运行的
BASH_SUBSHELL
```

检测是否开启子shell运行命令

```shell
sh-4.2# cd ~;pwd;ls ;cd /tmp/;pwd ;ls;echo ${BASH_SUBSHELL}
/root
anaconda-ks.cfg
/tmp
systemd-private-7b47f72631864e9ebc1bbf3d64cf90a5-chronyd.service-7ANwBd  systemd-private-e1149a55578f421a8582fc4c31b0cc77-chronyd.service-80UWg7
systemd-private-c12bcdca0f774c248b9c66b301dad2c2-chronyd.service-1hPhV4
0
```

明确开启子shell运行的命令

```shell
sh-4.2# (sh-4.2# cd ~;pwd;ls ;cd /tmp/;pwd ;ls;echo ${BASH_SUBSHELL})
sh: sh-4.2#: command not found
/tmp
systemd-private-7b47f72631864e9ebc1bbf3d64cf90a5-chronyd.service-7ANwBd  systemd-private-e1149a55578f421a8582fc4c31b0cc77-chronyd.service-80UWg7
systemd-private-c12bcdca0f774c248b9c66b301dad2c2-chronyd.service-1hPhV4
/tmp
systemd-private-7b47f72631864e9ebc1bbf3d64cf90a5-chronyd.service-7ANwBd  systemd-private-e1149a55578f421a8582fc4c31b0cc77-chronyd.service-80UWg7
systemd-private-c12bcdca0f774c248b9c66b301dad2c2-chronyd.service-1hPhV4
1
```

## 子shell嵌套运行

刚才是一个小括号，开启一个子shell运行命令，还可以嵌套多个

```shell
[root@keweizhou1 ~]# (pwd;(echo ${BASH_SUBSHELL}));
/root
2
[root@keweizhou1 ~]#
```

在shell脚本开发中，经常会用子shell进行多线程的处理，提高程序并发执行效率。

# 内置命令、外置命令
