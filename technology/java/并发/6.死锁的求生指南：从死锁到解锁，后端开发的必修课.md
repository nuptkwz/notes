[toc]

大家好，我是你们的技术老友**科威舟**，今天给大家分享一下常用Java中的死锁。

> 当我们谈死锁时，其实就像两个绅士在门口互相让路，都让对方先走，结果谁都走不了

作为一名后端开发者，死锁这个问题就像是一场恶梦。不管你是刚入门的新手，还是经验丰富的老兵，都可能在某个深夜被这个看似简单却又棘手的问题折磨得死去活来。今天，就让我们一起来深入剖析死锁，看看它到底是如何产生的，以及如何优雅地避免它。

## 一、什么是死锁？一个生动的比喻

想象一下，账户A需要向账户B转账，同时账户B也需要向账户A转账。两个转账操作都需要锁定两个账户的余额才能进行。这时，账户A先锁定了自己，然后尝试锁定账户B；同时账户B也锁定了自己，并尝试锁定账户A。结果就是，账户A等着账户B释放锁，账户B也等着账户A释放锁——双方陷入了永恒的等待，这就是死锁。

用更专业的术语来说，死锁就是两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。

## 二、死锁产生的四个必要条件

死锁的发生必须同时满足以下四个条件，缺一不可：

### 1. 互斥条件（Mutual Exclusion）
共享资源每次只能被一个线程使用。就像厕所只有一个坑位，一次只能容纳一个人。

### 2. 请求与保持条件（Hold and Wait）
一个线程因请求资源而阻塞时，对已获得的资源保持不放。这就像你一手拿着筷子，一手拿着碗，却还想要别人的勺子。

### 3. 不剥夺条件（No Preemption）
线程已获得的资源，在未使用完之前，不能被其他线程强行剥夺。这就像你不能从别人嘴里抢走食物一样。

### 4. 循环等待条件（Circular Wait）
若干线程之间形成一种头尾相接的循环等待资源关系。就像A等B，B等C，C又在等A，形成一个闭环。

**只要破坏这四个条件中的任意一个，死锁就不会发生。** 这是我们避免死锁的理论基础。

## 三、死锁的实战场景分析

### 场景一：数据库转账经典死锁

这是最常见的死锁场景，两个事务以不同顺序更新相同的记录：

```sql
-- 事务A
BEGIN;
UPDATE account SET balance = balance - 100 WHERE id = 1;
UPDATE account SET balance = balance + 100 WHERE id = 2;
COMMIT;

-- 事务B  
BEGIN;
UPDATE account SET balance = balance - 100 WHERE id = 2;
UPDATE account SET balance = balance + 100 WHERE id = 1;
COMMIT;
```

如果事务A执行完第一句，事务B也同时执行完第一句，那么事务A会等待事务B释放id=2的锁，而事务B也会等待事务A释放id=1的锁，形成死锁。

### 场景二：MySQL间隙锁死锁

在REPEATABLE READ隔离级别下，MySQL会使用间隙锁来防止幻读，这也可能导致死锁。

假设有一个用户积分表，现有数据为：id=1（user_id=1），id=3（user_id=3），id=5（user_id=5）。注意user_id为2和4的记录不存在。

事务A执行：
```sql
SELECT * FROM user_points WHERE user_id = 2 FOR UPDATE; -- 获取间隙锁(1,3)
INSERT INTO user_points(user_id, points) VALUES(2, 100); -- 等待事务B
```

事务B执行：
```sql  
SELECT * FROM user_points WHERE user_id = 4 FOR UPDATE; -- 获取间隙锁(3,5)
INSERT INTO user_points(user_id, points) VALUES(4, 100); -- 等待事务A
```

这就形成了死锁，因为每个事务都持有一个间隙锁，并等待对方释放锁。

### 场景三：C#异步编程中的死锁

在UI程序中，如果在UI线程中调用Task.Run并在其中使用.Result等待异步操作，很容易导致死锁：

```csharp
// UI线程代码
private void btnDeadlock_Click(object sender, EventArgs e)
{
    var result = Task.Run(() => {
        return DoSomethingAsync().Result; // ❌ 危险操作！
    }).Result;
    MessageBox.Show(result); // 这里永远卡住！
}

private async Task<string> DoSomethingAsync()
{
    await Task.Delay(1000);
    return "完成！";
}
```

这里的问题是：Task.Run在线程池线程执行DoSomethingAsync()，DoSomethingAsync()内部的await尝试返回到原始上下文（UI线程），但UI线程正在等待Task.Run完成，导致死锁。

## 四、如何避免和解决死锁

### 1. 破坏请求与保持条件：一次性申请所有资源

我们可以设计一个资源分配器，确保线程一次性申请所有需要的资源，如果无法满足就等待。

```java
public class Allocator {
    private List<Object> als = new ArrayList<>();
    
    synchronized boolean apply(Object from, Object to) {
        if (als.contains(from) || als.contains(to)) {
            return false;
        } else {
            als.add(from);
            als.add(to);
        }
        return true;
    }
    
    synchronized void free(Object from, Object to) {
        als.remove(from);
        als.remove(to);
    }
}

// 使用方式
void transfer(Account target, int amt) {
    while (!actr.apply(this, target)) {
        // 循环等待，直到成功申请到资源
    }
    try {
        // 执行转账操作
        synchronized (this) {
            synchronized (target) {
                // 业务逻辑
            }
        }
    } finally {
        actr.free(this, target);
    }
}
```

### 2. 破坏不可剥夺条件：使用定时锁

使用Lock类中的tryLock方法，指定一个超时时限，在等待超过该时间后返回失败信息。

```java
public class DeadLockSolution {
    public static ReentrantLock lock1 = new ReentrantLock();
    public static ReentrantLock lock2 = new ReentrantLock();
    
    public static void main(String[] args) {
        Thread thread1 = new Thread(() -> {
            while (true) {
                if (lock1.tryLock(1, TimeUnit.MILLISECONDS)) {
                    try {
                        if (lock2.tryLock(1, TimeUnit.MILLISECONDS)) {
                            try {
                                System.out.println("Thread1获取了两把锁");
                                return;
                            } finally {
                                lock2.unlock();
                            }
                        }
                    } finally {
                        lock1.unlock();
                    }
                }
            }
        });
    }
}
```

### 3. 破坏循环等待条件：资源有序分配法

对资源进行排序，要求线程按照一定的顺序申请资源。

```java
class Account {
    private int id;
    private int balance;
    
    void transfer(Account target, int amt) {
        Account left = this;
        Account right = target;
        
        // 按照id大小确定资源申请顺序
        if (this.id > target.id) {
            left = target;
            right = this;
        }
        
        synchronized(left) {
            synchronized(right) {
                if (this.balance > amt) {
                    this.balance -= amt;
                    target.balance += amt;
                }
            }
        }
    }
}
```

### 4. 数据库层面的死锁避免策略

**固定顺序访问**：确保所有事务按相同的顺序访问记录。

```sql
-- 事务A和事务B都按照id递增顺序更新
UPDATE account SET balance = balance - 100 WHERE id IN (1, 2) ORDER BY id;
```

**减小事务范围**：不要在一个大事务中做太多事情，拆分为多个小事务。

**设置锁等待超时**：通过参数控制锁等待时间。

```sql
SET innodb_lock_wait_timeout = 10; -- 设置10秒超时
```

**降低隔离级别**：在业务允许的情况下，考虑使用READ COMMITTED来减少锁冲突。

## 五、死锁检测与排查

当系统出现死锁时，我们需要工具来检测和排查。

### MySQL死锁检测

MySQL可以自动检测死锁并回滚其中一个事务，使用`SHOW ENGINE INNODB STATUS`可以查看最近一次死锁的详情。

### Java死锁检测

可以使用jvisualvm或jstack等工具检测Java程序中的死锁。

```bash
jstack <pid>
```

工具会显示线程状态和锁信息，帮助定位死锁发生的具体位置。

## 六、总结

死锁是并发编程中常见但又棘手的问题。通过今天的探讨，我们了解了死锁产生的四个必要条件，以及多种预防和避免死锁的策略。关键在于**破坏死锁产生的四个条件中的至少一个**。

在实际开发中，我建议：

1. **统一资源访问顺序**：这是最简单有效的方法
2. **使用超时机制**：避免无限期等待
3. **保持事务简洁**：尽快释放锁
4. **合理使用索引**：减少锁定的范围

死锁就像编程道路上的绊脚石，但只要我们掌握了正确的方法，就能轻松跨越。希望这篇文章能帮助你在今后的开发工作中更好地预防和解决死锁问题！

## 参考文章

1. http://mp.weixin.qq.com/s?__biz=Mzk0MzIyMDA1OA==&mid=2247495931&idx=3&sn=b934ab8d68d115aabffbcd4c64929b53&chksm=c2f967ec4b3413cd5ef4ae577377f0cf2e1efaf4fa6ccd1689d0f2fa52a197f290e8cd6dd625#rd
2. https://blog.csdn.net/HD_Cash/article/details/123964549
3. https://blog.csdn.net/nwbfygsjdr/article/details/140032712
4. http://m.blog.csdn.net/Swartz2015/article/details/64638357
5. https://blog.csdn.net/weixin_45372436/article/details/101637289
7. https://segmentfault.com/a/1190000046455928?sort=votes
8. https://segmentfault.com/a/1190000037512913?sort=newest
9. http://mp.weixin.qq.com/s?__biz=MzIwMTgyNDU0Ng==&mid=2247486459&idx=1&sn=0e0fe8eae405c2631b16e56308b6be2c&chksm=975b62f6fcd970ce187520922b77dd11566240387c08cba371535af7facdee994cae8976b6f3#rd
10. https://blog.csdn.net/z_344791576/article/details/148050684

**你是怎么解决死锁问题的呢？欢迎在评论区分享你的经验和困惑！**

---
更多技术干货欢迎关注微信公众号**科威舟的AI笔记**~

![](https://files.mdnice.com/user/101007/40fb2530-2565-4f14-a1df-8f581b1b1d70.png)

【转载须知】：**转载请注明原文出处及作者信息**

