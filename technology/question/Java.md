# Java
- HashMap的key要注意什么？
- HashMap原理？hash冲突了怎么办？为什么会线程不安全，具体哪里不安全？
- JDK1.8中对hash算法和寻址算法是如何优化的？
- 产线中如果有没有遇到内存爆满、cpu飙升的情况？
- 如何排查GC情况？
- ThreadLocal原理，为什么用弱引用？弱引用和强引用的区别？
- 产线cpu飙升很高，如何排查、定位和解决问题？
  核心思想：找到这台服务器，是哪个进程的哪个线程的哪段代码，导致cpu100%
  (1)定位耗费cpu的进程
     top -c: 显示进程列表，然后输入p,按照cpu使用率进行排序
     这样就能够看到哪个进程的cpu负载最高，还有启动这个进程的命令
  (2)定位耗时cpu的线程
     top -Hp xxx: 输入那个进程的id,然后输入p,按照cpu使用率进行排序
  (3)定位哪段代码导致的cpu过高
     printf "%x\n" xxx,把线程的pid换成16进制，比如yyy,然后
     jstack 进程id | grep '0xyyy' -C5 -color
     通过jstack来打印进程的堆栈信息，而且通过grep那个线程的16进制的pid，找到那个线程相关的东西，这个时候就可以在打印出的代码里，看到
     是哪个类的哪个方法导致的这个cpu 100%的问题。

- 产线Jvm内存过高如何排查？

- BIO、NIO、AIO、的区别？NIO是异步的吗？
  BIO：同步阻塞（针对的是磁盘文件的IO读写，FileInputStream,BIO卡在那里，直到你读写完成了才可以）
  NIO: 同步非阻塞（通过NIO的FileChannel发起个文件IO操作，发起之后就返回了而不是阻塞在那儿，你可以去干别的事情，这就是非阻塞。
       但是接下来你还得不断的去轮询操作系统，看IO操作完事了没有）
  AIO: 基于Proactor模型，是异步非阻塞模型（基于AIO的文件读写的api去读写磁盘文件，你发起一个文件读写的操作之后，交给操作系统，你就不去
       管它了，直到操作系统自己完成之后，会来回调你的一个接口，通知你说ok，这个数据读好了，那个数据写完了）

- Synchronized和Lock的区别？

- 进程间的通信方式？
  管道（pipe）、命名管道（fifo）、消息队列、共享内存

- Socket工作原理
  不同层的协议：
  应用层：http协议
  传输层：tcp协议，socket属于传输层的这么一个编程规范
  网络层：ip协议
  数据链路层：以太网协议

- 了解红黑树的数据结构吗？时间复杂度多少？

- 为什么要重写equals和hashcode方法？不重写会怎么样？
- treeMap和map哪个快？
- HashMap数组加链表链表变成数组怎么样？
- redis集群脑裂怎么办？如何避免脑裂？
- CountDownLatch和SemaPhone的区别？
- 简单工厂模式和抽象工厂模式的区别？

- Synchronized锁同时原子性、可见性以及有序性的保证
  原子性：
  可见性：
  有序性：
  synchronized关键字，同时可以保证原子性、可见性以及有序性的
  原子性层面，加了synchronized之后，就有一个加锁和释放锁的机制，加锁之后，同一段代码，只有它可以运行了
  可见性层面，可以保证可见性，他在同步代码块对变量做的写操作，都会在释放锁的时候，全部强制执行flush操作，
     在进入同步代码块的时候，对变量的读操作，全部会强制执行refresh的操作。


